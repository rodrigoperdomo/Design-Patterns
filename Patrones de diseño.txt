-------------------
Patrones de diseÃ±o
-------------------

- Patrones de diseÃ±o: Se puede pensar como una caja de herramientas, donde segÃºn que tipo de problema se pueda implementar una u otro patron.
Se pueden dividir en tres tipos:

- Creacionales
- Estructurales
- Comportamiento

----------------
Creacionales:
----------------

- Factory Method: La idea del patron del Factory Method es crear o instanciar clases desde un mÃ©todo sin mostrar al cliente la instancia por cada clase, sino dejarsela al metodo factory que lo haga.

- Builder Pattern: Cuando queremos crear una nueva clase que tiene muchos atributos, crear varios constructores no es la mejor opciÃ³n, la idea del builder pattern es generar a partir de una clase estatica estos atributos.

- Singleton Pattern: La idea del Singleton Pattern es que una clase tenga una unica instancia que se crea a partir de un metodo statico y la instancia tambiÃ©n sea estatica.

- Prototype Pattern: La idea principal del Prototype pattern es clonar objetos a partir de una clase base, se usa solamente cuando queremos cambiar algo especÃ­fico de la clase base pero manteniendo datos y estructura.

- Abstract Factory: A diferencia del factory Method, el abstract factory crea una familia de productos o instancias, en cambio en factory method se encarga de uno solo. La idea es hacer la creaciÃ³n de estos objetos con la
abtracciÃ³n de clases e interfaces.

---------------
Estructurales:
---------------

- Adapter Pattern:El patron adapter nos sirve para cuando tenemos dos clases incompatibles ya sea por distintas versiones o ejecuciÃ³n de librerÃ­a de terceros y lo necesitamos a una nueva clase, funciona crear una clase que adapte las dos clases o sirva de conexiÃ³n, por ejemplo un sistema que hacia reportes y retornaba en xml y ahora otro cliente pide el mismo reporte pero en json.

- Composite Pattern: El patron composite sirve para adjuntar clases o elementos a una clase en particular, lo hace a traves del interfaz que implementa, Por ejemplo cuando se trata de archivos y carpetas. En otras palabras
El Composite Pattern se usa cuando querÃ©s tratar objetos individuales y conjuntos de objetos de la misma forma.

Component
â”œâ”€â”€ Leaf
â””â”€â”€ Composite


- Decorator pattern: El Decorator Pattern te permite agregar funcionalidades a un objeto en tiempo de ejecuciÃ³n, envolviÃ©ndolo dentro de otro objeto que implementa la misma interfaz.

Component
â”œâ”€â”€ ConcreteComponent
â””â”€â”€ Decorator
     â”œâ”€â”€ ConcreteDecoratorA
     â””â”€â”€ ConcreteDecoratorB

- Facade Pattern : El patrÃ³n Facade proporciona una interfaz unificada y sencilla para un conjunto de sub-sistemas o clases complejas. Es como tener una â€œfachadaâ€ (una cara visible) que oculta toda la complejidad interna del sistema y ofrece solo los mÃ©todos necesarios al cliente.


Cliente â†’ Facade â†’ Subsistema A
                 â†’ Subsistema B
                 â†’ Subsistema C
- Bridge Pattern: El Bridge Pattern (Puente) es un patrÃ³n estructural que busca desacoplar una abstracciÃ³n de su implementaciÃ³n, de forma que ambas puedan variar independientemente.

ğŸ‘‰ Es decir: en vez de tener una jerarquÃ­a gigante de clases que combinan varias dimensiones (por ejemplo, Forma + MÃ©todo de Dibujo), el patrÃ³n divide esas dimensiones en dos jerarquÃ­as separadas que se conectan mediante un â€œpuenteâ€.

          Abstraction (Forma)
                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
Refined Abstraction   (CÃ­rculo, RectÃ¡ngulo)

                 â†“ (usa)
           Implementor (API de dibujo)
                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
ConcreteImplementor1   ConcreteImplementor2
(API1, API2, etc.)


--------------
Comportamiento
--------------

- Observer Pattern: El patrÃ³n Observer define una relaciÃ³n uno a muchos entre objetos, de manera que cuando un objeto cambia su estado (el sujeto), todos sus observadores son notificados automÃ¡ticamente.
ğŸ‘‰ En otras palabras:
â€œCuando algo cambia, los interesados se enteran.â€

            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚   Subject    â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ attach()     â”‚                         â”‚
            â”‚ detach()     â”‚                         â”‚
            â”‚ notify()     â”‚                         â”‚
            â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
                   â”‚                                 â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
        â”‚ ConcreteSubject     â”‚                      â”‚
        â”‚ - state             â”‚                      â”‚
        â”‚ + getState()        â”‚                      â”‚
        â”‚ + setState()        â”‚â”€â”€â”€(llama notify())â”€â”€â”€â”˜
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚   Observer     â”‚
           â”‚ + update()     â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ ConcreteObserver    â”‚
        â”‚ - subject           â”‚
        â”‚ + update()          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


- Strategy Pattern: El patrÃ³n Strategy te permite definir una familia de algoritmos, encapsular cada uno, y hacerlos intercambiables.
La idea es separar el comportamiento (la estrategia) del contexto (la clase que la usa).

Esto evita tener grandes estructuras if o switch para elegir un comportamiento, y en su lugar puedes cambiar el comportamiento en tiempo de ejecuciÃ³n.

ImaginÃ¡ que estÃ¡s desarrollando un sistema de pago para un e-commerce.
QuerÃ©s soportar pago con tarjeta, PayPal y criptomonedas.
Sin el patrÃ³n Strategy, quizÃ¡s harÃ­as algo asÃ­:

if (metodo.equals("tarjeta")) {
    // lÃ³gica para tarjeta
} else if (metodo.equals("paypal")) {
    // lÃ³gica para PayPal
} else if (metodo.equals("cripto")) {
    // lÃ³gica para cripto
}


Esto es difÃ­cil de mantener y extender.
Con Strategy, podÃ©s hacerlo mucho mÃ¡s limpio ğŸ‘‡


ğŸ’¡ Ventajas
âœ… Evita el uso de muchos if o switch
âœ… Permite agregar nuevas estrategias sin modificar el cÃ³digo existente
âœ… Hace el cÃ³digo mÃ¡s abierto a extensiÃ³n y cerrado a modificaciÃ³n (Principio Open/Closed)

âš ï¸ Desventajas
âŒ Puede aumentar el nÃºmero de clases
âŒ Requiere que el cliente sepa quÃ© estrategia usar
